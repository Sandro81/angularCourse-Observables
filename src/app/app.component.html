<div class="container">
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <a routerLink="/">Home</a> |
      <a [routerLink]="['user', 1]">
        User 1
      </a>
      |
      <a [routerLink]="['user', 2]">
        User 2
      </a>
    </div>
  </div>
  <hr />
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <router-outlet></router-outlet>
    </div>
  </div>
</div>
<div class="container">
  <div class="row">
    <div class="col">
      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Section 13: Understanding Observables</h5>
        </div>
      </div>

      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 170. Getting Closer to the Core of Observables - prevent memory leaks</h5>
          <p class="card-text"> To build our own observable here in ngOnInit and for that, we can import something from that RxJS package. </p>
          <p class="card-text">First -> <code>import &#123; interval } from 'rxjs';</code></p>
          <p>The following code create an observable that will count each 1000 second a number -> <code>ngOnInit() &#123;
            interval( 1000).subscribe(count => &#123;
            console.log(count);
            });
            }</code></p>
          <p class="card-text"> To prevent memory leaks, we need to destroy the subscription. <br>
            To do that we need to store the previous subscription <code>private firstObsSubscription: Subscription;</code><br>
          and than drestroy that using -> <code> ngOnDestroy(): void &#123;
              this.firstObsSubscription.unsubscribe();
              }</code></p>
        </div>
      </div>

      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson 171. Building a Custom Observable </h5>
          <p class="card-text"> Store the Custom Observable into a constant. Instance a new Observable object to create an Observable. Then we need to pass into an anonymous arrow function the observer argument. The observer in the end is a part that is interested in being informed about new data, about errors or about the observable being completed.<br>
            <code>const customIntervalObservable = new Observable(observer => &#123;<br></code>
            -> Now our job here is to tell the observer about new data, about an error or about the observable being completed. Here, we're not responsible for listening because the observer is the listener, here we get that listening part as an argument and we need to tell it once we're done, once new data is there and so on.
            <br>
            <code>
            let count = 0;<br>
              setInterval( () => &#123;<br></code>
            -> We can call the next method to emit a new value.<br>
          <code>
            observer.next(count);<br>
            count++;<br>
            }, 1000);<br>
            });<br> </code>
            -> An Observable instance begins publishing values only when someone subscribes to it. You subscribe by calling the <a href="https://angular.io/guide/observables#subscribing" target="_blank">subscribe()</a>  method of the instance, passing an observer object to receive the notifications.
            <br>
            <code>
            this.firstObsSubscription = customIntervalObservable.subscribe(data => &#123;<br>
            console.log(data);<br>
            });<br>
              } </code></p>
        </div>
      </div>


      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson  172. Errors & Completion </h5>
          <h6>ERROR:</h6>
          <p class="card-text"> The error observable method can be used to handler the error during the subscription, for example: </p>
          <p class="card-text"> <code> ngOnInit()  &#123;<br>
    const customIntervalObservable = new Observable(observer =>  &#123;<br>
            let count = 0;<br>
            setInterval( () =>  &#123;<br>
            observer.next(count);<br>
            count++;<br>
            if(count > 3)  &#123; </code><br>
            -> To emit the error message, we need to call the .error method <br>
            <code><b>observer.error(new Error('Count is greater 3!'));</b><br>
            }<br>
            }, 1000);<br>
            });<br>
    this.firstObsSubscription = customIntervalObservable.subscribe(data =>  &#123;<br>
            console.log(data);<br>
            }, <b>error</b> =>  &#123;<br>
            </code>
            -> to handler the error we need to pass another argument to subscribe<br>
            <code>
            console.log(error);
            });
            }</code></p>
          <h6>COMPLETE:</h6>
          <p class="card-text">  well then we simply call observer complete and there, you don't need to pass any arguments. <code>observer.complete(); </code> when you call complete, the observable will really come to a halt</p>

          <p>  <code>  this.firstObsSubscription = customIntervalObservable.subscribe(data =>  &#123;<br>
            console.log(data);<br>
            }, error =>  &#123;
            console.log(error);<br>
            }, () =>  &#123; <br></code>
            Now if you want to react to that completion, you can add a third arguments to the subscribe method and that is your completion handler function. It's a function that gets no arguments because completing doesn't pass any arguments and it's simply a function where you can do some cleanup work or whatever you need to do and here I'll just log completed. Also important, you don't need to unsubscribe<br>
            <code>
            console.log('Completed!');<br>
            });</code></p>


        </div>
      </div>



      <!--
      <br>
      <div class="card">
        <div class="card-body">
          <h5 class="card-title">Lesson xxx -> </h5>
          <p class="card-text"> - </p>
          <p class="card-text"> <code>routerLink="/servers" </code></p>
        </div>
      </div>
-->







    </div>
  </div>
</div>
